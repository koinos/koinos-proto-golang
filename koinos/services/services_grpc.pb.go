// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             v3.17.3
// source: koinos/rpc/services.proto

package services

import (
	context "context"
	account_history "github.com/koinos/koinos-proto-golang/koinos/rpc/account_history"
	block_store "github.com/koinos/koinos-proto-golang/koinos/rpc/block_store"
	chain "github.com/koinos/koinos-proto-golang/koinos/rpc/chain"
	contract_meta_store "github.com/koinos/koinos-proto-golang/koinos/rpc/contract_meta_store"
	mempool "github.com/koinos/koinos-proto-golang/koinos/rpc/mempool"
	p2p "github.com/koinos/koinos-proto-golang/koinos/rpc/p2p"
	transaction_store "github.com/koinos/koinos-proto-golang/koinos/rpc/transaction_store"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// KoinosClient is the client API for Koinos service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type KoinosClient interface {
	// Account History
	GetAccountHistory(ctx context.Context, in *account_history.GetAccountHistoryRequest, opts ...grpc.CallOption) (*account_history.GetAccountHistoryResponse, error)
	// Block Store
	GetBlocksById(ctx context.Context, in *block_store.GetBlocksByIdRequest, opts ...grpc.CallOption) (*block_store.GetBlocksByIdResponse, error)
	GetBlocksByHeight(ctx context.Context, in *block_store.GetBlocksByHeightRequest, opts ...grpc.CallOption) (*block_store.GetBlocksByHeightResponse, error)
	GetHighestBlock(ctx context.Context, in *block_store.GetHighestBlockRequest, opts ...grpc.CallOption) (*block_store.GetHighestBlockResponse, error)
	// Chain
	SubmitBlock(ctx context.Context, in *chain.SubmitBlockRequest, opts ...grpc.CallOption) (*chain.SubmitBlockResponse, error)
	SubmitTransaction(ctx context.Context, in *chain.SubmitTransactionRequest, opts ...grpc.CallOption) (*chain.SubmitTransactionResponse, error)
	GetHeadInfo(ctx context.Context, in *chain.GetHeadInfoRequest, opts ...grpc.CallOption) (*chain.GetHeadInfoResponse, error)
	GetChainId(ctx context.Context, in *chain.GetChainIdRequest, opts ...grpc.CallOption) (*chain.GetChainIdResponse, error)
	GetForkHeads(ctx context.Context, in *chain.GetForkHeadsRequest, opts ...grpc.CallOption) (*chain.GetForkHeadsResponse, error)
	ReadContract(ctx context.Context, in *chain.ReadContractRequest, opts ...grpc.CallOption) (*chain.ReadContractResponse, error)
	GetAccountNonce(ctx context.Context, in *chain.GetAccountNonceRequest, opts ...grpc.CallOption) (*chain.GetAccountNonceResponse, error)
	GetAccountRc(ctx context.Context, in *chain.GetAccountRcRequest, opts ...grpc.CallOption) (*chain.GetAccountRcResponse, error)
	GetResourceLimits(ctx context.Context, in *chain.GetResourceLimitsRequest, opts ...grpc.CallOption) (*chain.GetResourceLimitsResponse, error)
	// Contract Meta Store
	GetContractMeta(ctx context.Context, in *contract_meta_store.GetContractMetaRequest, opts ...grpc.CallOption) (*contract_meta_store.GetContractMetaResponse, error)
	// Mempool
	GetPendingTransactions(ctx context.Context, in *mempool.GetPendingTransactionsRequest, opts ...grpc.CallOption) (*mempool.GetPendingTransactionsResponse, error)
	CheckPendingAccountResources(ctx context.Context, in *mempool.CheckPendingAccountResourcesRequest, opts ...grpc.CallOption) (*mempool.CheckPendingAccountResourcesResponse, error)
	// P2P
	GetGossipStatus(ctx context.Context, in *p2p.GetGossipStatusRequest, opts ...grpc.CallOption) (*p2p.GetGossipStatusResponse, error)
	// Transaction Store
	GetTransactionsById(ctx context.Context, in *transaction_store.GetTransactionsByIdRequest, opts ...grpc.CallOption) (*transaction_store.GetTransactionsByIdResponse, error)
}

type koinosClient struct {
	cc grpc.ClientConnInterface
}

func NewKoinosClient(cc grpc.ClientConnInterface) KoinosClient {
	return &koinosClient{cc}
}

func (c *koinosClient) GetAccountHistory(ctx context.Context, in *account_history.GetAccountHistoryRequest, opts ...grpc.CallOption) (*account_history.GetAccountHistoryResponse, error) {
	out := new(account_history.GetAccountHistoryResponse)
	err := c.cc.Invoke(ctx, "/koinos.services.koinos/get_account_history", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *koinosClient) GetBlocksById(ctx context.Context, in *block_store.GetBlocksByIdRequest, opts ...grpc.CallOption) (*block_store.GetBlocksByIdResponse, error) {
	out := new(block_store.GetBlocksByIdResponse)
	err := c.cc.Invoke(ctx, "/koinos.services.koinos/get_blocks_by_id", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *koinosClient) GetBlocksByHeight(ctx context.Context, in *block_store.GetBlocksByHeightRequest, opts ...grpc.CallOption) (*block_store.GetBlocksByHeightResponse, error) {
	out := new(block_store.GetBlocksByHeightResponse)
	err := c.cc.Invoke(ctx, "/koinos.services.koinos/get_blocks_by_height", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *koinosClient) GetHighestBlock(ctx context.Context, in *block_store.GetHighestBlockRequest, opts ...grpc.CallOption) (*block_store.GetHighestBlockResponse, error) {
	out := new(block_store.GetHighestBlockResponse)
	err := c.cc.Invoke(ctx, "/koinos.services.koinos/get_highest_block", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *koinosClient) SubmitBlock(ctx context.Context, in *chain.SubmitBlockRequest, opts ...grpc.CallOption) (*chain.SubmitBlockResponse, error) {
	out := new(chain.SubmitBlockResponse)
	err := c.cc.Invoke(ctx, "/koinos.services.koinos/submit_block", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *koinosClient) SubmitTransaction(ctx context.Context, in *chain.SubmitTransactionRequest, opts ...grpc.CallOption) (*chain.SubmitTransactionResponse, error) {
	out := new(chain.SubmitTransactionResponse)
	err := c.cc.Invoke(ctx, "/koinos.services.koinos/submit_transaction", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *koinosClient) GetHeadInfo(ctx context.Context, in *chain.GetHeadInfoRequest, opts ...grpc.CallOption) (*chain.GetHeadInfoResponse, error) {
	out := new(chain.GetHeadInfoResponse)
	err := c.cc.Invoke(ctx, "/koinos.services.koinos/get_head_info", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *koinosClient) GetChainId(ctx context.Context, in *chain.GetChainIdRequest, opts ...grpc.CallOption) (*chain.GetChainIdResponse, error) {
	out := new(chain.GetChainIdResponse)
	err := c.cc.Invoke(ctx, "/koinos.services.koinos/get_chain_id", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *koinosClient) GetForkHeads(ctx context.Context, in *chain.GetForkHeadsRequest, opts ...grpc.CallOption) (*chain.GetForkHeadsResponse, error) {
	out := new(chain.GetForkHeadsResponse)
	err := c.cc.Invoke(ctx, "/koinos.services.koinos/get_fork_heads", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *koinosClient) ReadContract(ctx context.Context, in *chain.ReadContractRequest, opts ...grpc.CallOption) (*chain.ReadContractResponse, error) {
	out := new(chain.ReadContractResponse)
	err := c.cc.Invoke(ctx, "/koinos.services.koinos/read_contract", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *koinosClient) GetAccountNonce(ctx context.Context, in *chain.GetAccountNonceRequest, opts ...grpc.CallOption) (*chain.GetAccountNonceResponse, error) {
	out := new(chain.GetAccountNonceResponse)
	err := c.cc.Invoke(ctx, "/koinos.services.koinos/get_account_nonce", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *koinosClient) GetAccountRc(ctx context.Context, in *chain.GetAccountRcRequest, opts ...grpc.CallOption) (*chain.GetAccountRcResponse, error) {
	out := new(chain.GetAccountRcResponse)
	err := c.cc.Invoke(ctx, "/koinos.services.koinos/get_account_rc", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *koinosClient) GetResourceLimits(ctx context.Context, in *chain.GetResourceLimitsRequest, opts ...grpc.CallOption) (*chain.GetResourceLimitsResponse, error) {
	out := new(chain.GetResourceLimitsResponse)
	err := c.cc.Invoke(ctx, "/koinos.services.koinos/get_resource_limits", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *koinosClient) GetContractMeta(ctx context.Context, in *contract_meta_store.GetContractMetaRequest, opts ...grpc.CallOption) (*contract_meta_store.GetContractMetaResponse, error) {
	out := new(contract_meta_store.GetContractMetaResponse)
	err := c.cc.Invoke(ctx, "/koinos.services.koinos/get_contract_meta", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *koinosClient) GetPendingTransactions(ctx context.Context, in *mempool.GetPendingTransactionsRequest, opts ...grpc.CallOption) (*mempool.GetPendingTransactionsResponse, error) {
	out := new(mempool.GetPendingTransactionsResponse)
	err := c.cc.Invoke(ctx, "/koinos.services.koinos/get_pending_transactions", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *koinosClient) CheckPendingAccountResources(ctx context.Context, in *mempool.CheckPendingAccountResourcesRequest, opts ...grpc.CallOption) (*mempool.CheckPendingAccountResourcesResponse, error) {
	out := new(mempool.CheckPendingAccountResourcesResponse)
	err := c.cc.Invoke(ctx, "/koinos.services.koinos/check_pending_account_resources", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *koinosClient) GetGossipStatus(ctx context.Context, in *p2p.GetGossipStatusRequest, opts ...grpc.CallOption) (*p2p.GetGossipStatusResponse, error) {
	out := new(p2p.GetGossipStatusResponse)
	err := c.cc.Invoke(ctx, "/koinos.services.koinos/get_gossip_status", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *koinosClient) GetTransactionsById(ctx context.Context, in *transaction_store.GetTransactionsByIdRequest, opts ...grpc.CallOption) (*transaction_store.GetTransactionsByIdResponse, error) {
	out := new(transaction_store.GetTransactionsByIdResponse)
	err := c.cc.Invoke(ctx, "/koinos.services.koinos/get_transactions_by_id", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// KoinosServer is the server API for Koinos service.
// All implementations must embed UnimplementedKoinosServer
// for forward compatibility
type KoinosServer interface {
	// Account History
	GetAccountHistory(context.Context, *account_history.GetAccountHistoryRequest) (*account_history.GetAccountHistoryResponse, error)
	// Block Store
	GetBlocksById(context.Context, *block_store.GetBlocksByIdRequest) (*block_store.GetBlocksByIdResponse, error)
	GetBlocksByHeight(context.Context, *block_store.GetBlocksByHeightRequest) (*block_store.GetBlocksByHeightResponse, error)
	GetHighestBlock(context.Context, *block_store.GetHighestBlockRequest) (*block_store.GetHighestBlockResponse, error)
	// Chain
	SubmitBlock(context.Context, *chain.SubmitBlockRequest) (*chain.SubmitBlockResponse, error)
	SubmitTransaction(context.Context, *chain.SubmitTransactionRequest) (*chain.SubmitTransactionResponse, error)
	GetHeadInfo(context.Context, *chain.GetHeadInfoRequest) (*chain.GetHeadInfoResponse, error)
	GetChainId(context.Context, *chain.GetChainIdRequest) (*chain.GetChainIdResponse, error)
	GetForkHeads(context.Context, *chain.GetForkHeadsRequest) (*chain.GetForkHeadsResponse, error)
	ReadContract(context.Context, *chain.ReadContractRequest) (*chain.ReadContractResponse, error)
	GetAccountNonce(context.Context, *chain.GetAccountNonceRequest) (*chain.GetAccountNonceResponse, error)
	GetAccountRc(context.Context, *chain.GetAccountRcRequest) (*chain.GetAccountRcResponse, error)
	GetResourceLimits(context.Context, *chain.GetResourceLimitsRequest) (*chain.GetResourceLimitsResponse, error)
	// Contract Meta Store
	GetContractMeta(context.Context, *contract_meta_store.GetContractMetaRequest) (*contract_meta_store.GetContractMetaResponse, error)
	// Mempool
	GetPendingTransactions(context.Context, *mempool.GetPendingTransactionsRequest) (*mempool.GetPendingTransactionsResponse, error)
	CheckPendingAccountResources(context.Context, *mempool.CheckPendingAccountResourcesRequest) (*mempool.CheckPendingAccountResourcesResponse, error)
	// P2P
	GetGossipStatus(context.Context, *p2p.GetGossipStatusRequest) (*p2p.GetGossipStatusResponse, error)
	// Transaction Store
	GetTransactionsById(context.Context, *transaction_store.GetTransactionsByIdRequest) (*transaction_store.GetTransactionsByIdResponse, error)
	mustEmbedUnimplementedKoinosServer()
}

// UnimplementedKoinosServer must be embedded to have forward compatible implementations.
type UnimplementedKoinosServer struct {
}

func (UnimplementedKoinosServer) GetAccountHistory(context.Context, *account_history.GetAccountHistoryRequest) (*account_history.GetAccountHistoryResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAccountHistory not implemented")
}
func (UnimplementedKoinosServer) GetBlocksById(context.Context, *block_store.GetBlocksByIdRequest) (*block_store.GetBlocksByIdResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBlocksById not implemented")
}
func (UnimplementedKoinosServer) GetBlocksByHeight(context.Context, *block_store.GetBlocksByHeightRequest) (*block_store.GetBlocksByHeightResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBlocksByHeight not implemented")
}
func (UnimplementedKoinosServer) GetHighestBlock(context.Context, *block_store.GetHighestBlockRequest) (*block_store.GetHighestBlockResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetHighestBlock not implemented")
}
func (UnimplementedKoinosServer) SubmitBlock(context.Context, *chain.SubmitBlockRequest) (*chain.SubmitBlockResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SubmitBlock not implemented")
}
func (UnimplementedKoinosServer) SubmitTransaction(context.Context, *chain.SubmitTransactionRequest) (*chain.SubmitTransactionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SubmitTransaction not implemented")
}
func (UnimplementedKoinosServer) GetHeadInfo(context.Context, *chain.GetHeadInfoRequest) (*chain.GetHeadInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetHeadInfo not implemented")
}
func (UnimplementedKoinosServer) GetChainId(context.Context, *chain.GetChainIdRequest) (*chain.GetChainIdResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetChainId not implemented")
}
func (UnimplementedKoinosServer) GetForkHeads(context.Context, *chain.GetForkHeadsRequest) (*chain.GetForkHeadsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetForkHeads not implemented")
}
func (UnimplementedKoinosServer) ReadContract(context.Context, *chain.ReadContractRequest) (*chain.ReadContractResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReadContract not implemented")
}
func (UnimplementedKoinosServer) GetAccountNonce(context.Context, *chain.GetAccountNonceRequest) (*chain.GetAccountNonceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAccountNonce not implemented")
}
func (UnimplementedKoinosServer) GetAccountRc(context.Context, *chain.GetAccountRcRequest) (*chain.GetAccountRcResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAccountRc not implemented")
}
func (UnimplementedKoinosServer) GetResourceLimits(context.Context, *chain.GetResourceLimitsRequest) (*chain.GetResourceLimitsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetResourceLimits not implemented")
}
func (UnimplementedKoinosServer) GetContractMeta(context.Context, *contract_meta_store.GetContractMetaRequest) (*contract_meta_store.GetContractMetaResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetContractMeta not implemented")
}
func (UnimplementedKoinosServer) GetPendingTransactions(context.Context, *mempool.GetPendingTransactionsRequest) (*mempool.GetPendingTransactionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetPendingTransactions not implemented")
}
func (UnimplementedKoinosServer) CheckPendingAccountResources(context.Context, *mempool.CheckPendingAccountResourcesRequest) (*mempool.CheckPendingAccountResourcesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CheckPendingAccountResources not implemented")
}
func (UnimplementedKoinosServer) GetGossipStatus(context.Context, *p2p.GetGossipStatusRequest) (*p2p.GetGossipStatusResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetGossipStatus not implemented")
}
func (UnimplementedKoinosServer) GetTransactionsById(context.Context, *transaction_store.GetTransactionsByIdRequest) (*transaction_store.GetTransactionsByIdResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTransactionsById not implemented")
}
func (UnimplementedKoinosServer) mustEmbedUnimplementedKoinosServer() {}

// UnsafeKoinosServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to KoinosServer will
// result in compilation errors.
type UnsafeKoinosServer interface {
	mustEmbedUnimplementedKoinosServer()
}

func RegisterKoinosServer(s grpc.ServiceRegistrar, srv KoinosServer) {
	s.RegisterService(&Koinos_ServiceDesc, srv)
}

func _Koinos_GetAccountHistory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(account_history.GetAccountHistoryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KoinosServer).GetAccountHistory(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/koinos.services.koinos/get_account_history",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KoinosServer).GetAccountHistory(ctx, req.(*account_history.GetAccountHistoryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Koinos_GetBlocksById_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(block_store.GetBlocksByIdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KoinosServer).GetBlocksById(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/koinos.services.koinos/get_blocks_by_id",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KoinosServer).GetBlocksById(ctx, req.(*block_store.GetBlocksByIdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Koinos_GetBlocksByHeight_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(block_store.GetBlocksByHeightRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KoinosServer).GetBlocksByHeight(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/koinos.services.koinos/get_blocks_by_height",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KoinosServer).GetBlocksByHeight(ctx, req.(*block_store.GetBlocksByHeightRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Koinos_GetHighestBlock_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(block_store.GetHighestBlockRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KoinosServer).GetHighestBlock(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/koinos.services.koinos/get_highest_block",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KoinosServer).GetHighestBlock(ctx, req.(*block_store.GetHighestBlockRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Koinos_SubmitBlock_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(chain.SubmitBlockRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KoinosServer).SubmitBlock(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/koinos.services.koinos/submit_block",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KoinosServer).SubmitBlock(ctx, req.(*chain.SubmitBlockRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Koinos_SubmitTransaction_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(chain.SubmitTransactionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KoinosServer).SubmitTransaction(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/koinos.services.koinos/submit_transaction",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KoinosServer).SubmitTransaction(ctx, req.(*chain.SubmitTransactionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Koinos_GetHeadInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(chain.GetHeadInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KoinosServer).GetHeadInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/koinos.services.koinos/get_head_info",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KoinosServer).GetHeadInfo(ctx, req.(*chain.GetHeadInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Koinos_GetChainId_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(chain.GetChainIdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KoinosServer).GetChainId(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/koinos.services.koinos/get_chain_id",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KoinosServer).GetChainId(ctx, req.(*chain.GetChainIdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Koinos_GetForkHeads_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(chain.GetForkHeadsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KoinosServer).GetForkHeads(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/koinos.services.koinos/get_fork_heads",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KoinosServer).GetForkHeads(ctx, req.(*chain.GetForkHeadsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Koinos_ReadContract_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(chain.ReadContractRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KoinosServer).ReadContract(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/koinos.services.koinos/read_contract",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KoinosServer).ReadContract(ctx, req.(*chain.ReadContractRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Koinos_GetAccountNonce_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(chain.GetAccountNonceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KoinosServer).GetAccountNonce(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/koinos.services.koinos/get_account_nonce",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KoinosServer).GetAccountNonce(ctx, req.(*chain.GetAccountNonceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Koinos_GetAccountRc_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(chain.GetAccountRcRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KoinosServer).GetAccountRc(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/koinos.services.koinos/get_account_rc",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KoinosServer).GetAccountRc(ctx, req.(*chain.GetAccountRcRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Koinos_GetResourceLimits_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(chain.GetResourceLimitsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KoinosServer).GetResourceLimits(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/koinos.services.koinos/get_resource_limits",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KoinosServer).GetResourceLimits(ctx, req.(*chain.GetResourceLimitsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Koinos_GetContractMeta_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(contract_meta_store.GetContractMetaRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KoinosServer).GetContractMeta(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/koinos.services.koinos/get_contract_meta",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KoinosServer).GetContractMeta(ctx, req.(*contract_meta_store.GetContractMetaRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Koinos_GetPendingTransactions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(mempool.GetPendingTransactionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KoinosServer).GetPendingTransactions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/koinos.services.koinos/get_pending_transactions",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KoinosServer).GetPendingTransactions(ctx, req.(*mempool.GetPendingTransactionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Koinos_CheckPendingAccountResources_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(mempool.CheckPendingAccountResourcesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KoinosServer).CheckPendingAccountResources(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/koinos.services.koinos/check_pending_account_resources",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KoinosServer).CheckPendingAccountResources(ctx, req.(*mempool.CheckPendingAccountResourcesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Koinos_GetGossipStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(p2p.GetGossipStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KoinosServer).GetGossipStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/koinos.services.koinos/get_gossip_status",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KoinosServer).GetGossipStatus(ctx, req.(*p2p.GetGossipStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Koinos_GetTransactionsById_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(transaction_store.GetTransactionsByIdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KoinosServer).GetTransactionsById(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/koinos.services.koinos/get_transactions_by_id",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KoinosServer).GetTransactionsById(ctx, req.(*transaction_store.GetTransactionsByIdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Koinos_ServiceDesc is the grpc.ServiceDesc for Koinos service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Koinos_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "koinos.services.koinos",
	HandlerType: (*KoinosServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "get_account_history",
			Handler:    _Koinos_GetAccountHistory_Handler,
		},
		{
			MethodName: "get_blocks_by_id",
			Handler:    _Koinos_GetBlocksById_Handler,
		},
		{
			MethodName: "get_blocks_by_height",
			Handler:    _Koinos_GetBlocksByHeight_Handler,
		},
		{
			MethodName: "get_highest_block",
			Handler:    _Koinos_GetHighestBlock_Handler,
		},
		{
			MethodName: "submit_block",
			Handler:    _Koinos_SubmitBlock_Handler,
		},
		{
			MethodName: "submit_transaction",
			Handler:    _Koinos_SubmitTransaction_Handler,
		},
		{
			MethodName: "get_head_info",
			Handler:    _Koinos_GetHeadInfo_Handler,
		},
		{
			MethodName: "get_chain_id",
			Handler:    _Koinos_GetChainId_Handler,
		},
		{
			MethodName: "get_fork_heads",
			Handler:    _Koinos_GetForkHeads_Handler,
		},
		{
			MethodName: "read_contract",
			Handler:    _Koinos_ReadContract_Handler,
		},
		{
			MethodName: "get_account_nonce",
			Handler:    _Koinos_GetAccountNonce_Handler,
		},
		{
			MethodName: "get_account_rc",
			Handler:    _Koinos_GetAccountRc_Handler,
		},
		{
			MethodName: "get_resource_limits",
			Handler:    _Koinos_GetResourceLimits_Handler,
		},
		{
			MethodName: "get_contract_meta",
			Handler:    _Koinos_GetContractMeta_Handler,
		},
		{
			MethodName: "get_pending_transactions",
			Handler:    _Koinos_GetPendingTransactions_Handler,
		},
		{
			MethodName: "check_pending_account_resources",
			Handler:    _Koinos_CheckPendingAccountResources_Handler,
		},
		{
			MethodName: "get_gossip_status",
			Handler:    _Koinos_GetGossipStatus_Handler,
		},
		{
			MethodName: "get_transactions_by_id",
			Handler:    _Koinos_GetTransactionsById_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "koinos/rpc/services.proto",
}
